<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zictionary</title>
    <!-- Load Tailwind CSS for responsive and clean styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Load custom font from GitHub CDN */
        @font-face {
            font-family: 'Proportional';
            src: url('https://cdn.jsdelivr.net/gh/26F-Studio/Techmino@main/parts/fonts/proportional.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap; /* Ensure font is displayed even if loading is slow */
        }

        /* Set root background to pure black for OLED displays */
        :root {
            color-scheme: dark light;
            background-color: black;
        }

        /* Apply custom font and transition for theme changes */
        body {
            font-family: 'Proportional', 'Inter', sans-serif; /* Apply custom font */
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: transparent; /* Ensure canvas background is visible */
        }

        /* CSS for the star background canvas, ensuring it's behind other content and full screen */
        canvas#background {
            position: fixed; /* Fixed position relative to the viewport */
            left: 0;         /* Align to top-left corner */
            top: 0;
            width: 100%;     /* Full width */
            width: 100vw;    /* Full viewport width */
            width: 100lvw;   /* Dynamic viewport width (for supported browsers) */
            height: 100%;    /* Full height */
            height: 100vh;   /* Full viewport height */
            height: 100lvh;  /* Dynamic viewport height (for supported browsers) */
            z-index: -1;     /* Place canvas behind other content */
        }

        /* Dark mode base styles, applied when 'dark' class is present on html tag */
        html.dark {
            background-color: #000000; /* Pure black for OLED */
            color: #e2e8f0; /* Light gray text */
        }
        html.dark .text-gray-800 { color: #e2e8f0; }

        /* Component backgrounds with 0.75 opacity */
        html.dark .bg-white { background-color: rgba(26, 26, 26, 0.75); } /* Darker gray for main components */
        html.dark .shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3); }
        html.dark .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.6), 0 4px 6px -2px rgba(0, 0, 0, 0.2); }

        /* Header colors */
        html.dark .text-green-600 { color: #48bb78; } /* Slightly brighter green for dark mode header */

        /* Search input colors with 0.75 opacity */
        html.dark .bg-green-50 { background-color: rgba(34, 34, 34, 0.75); } /* Darker background for input */
        html.dark .border-green-300 { border-color: #2f855a; } /* Darker green border */
        html.dark .focus\:ring-green-400:focus { --tw-ring-color: #2f855a; }
        html.dark .text-green-700 { color: #e2e8f0; }
        /* Improve contrast for placeholder text in dark mode */
        html.dark .placeholder-green-400::placeholder { color: #d0d0d0; } /* Lighter for better readability */
        html.dark svg.text-green-400 { color: #48bb78; }

        /* Keyword list header */
        html.dark .text-green-600 { color: #48bb78; }
        html.dark .border-green-200 { border-color: #2f855a; }

        /* Keyword list items with 0.75 opacity */
        html.dark .hover\:bg-green-100:hover { background-color: rgba(34, 34, 34, 0.75); } /* Darker hover */
        html.dark .active\:bg-green-200:active { background-color: rgba(10, 10, 10, 0.75); } /* Even darker active */
        html.dark .text-sm.font-medium { color: #e2e8f0; } /* Default text color in dark mode */

        /* Active keyword item with 0.75 opacity */
        html.dark .bg-green-100 { background-color: rgba(10, 10, 10, 0.75); } /* Darker background for active */
        html.dark .text-green-800 { color: #81e6d9; } /* Lighter text for active */

        /* Content section */
        html.dark .text-green-700 { color: #48bb78; }
        html.dark .border-green-300 { border-color: #2f855a; }
        html.dark .text-gray-700 { color: #cbd5e0; }

        /* Link button */
        html.dark .bg-green-500 { background-color: #2f855a; } /* Darker green button */
        html.dark .hover\:bg-green-600:hover { background-color: #276749; } /* Even darker hover */
        html.dark .focus\:ring-green-400:focus { --tw-ring-color: #2f855a; }

        /* Info box with 0.75 opacity */
        html.dark .p-4.bg-gray-100 { background-color: rgba(34, 34, 34, 0.75); } /* Darker background */
        html.dark .border-gray-200 { border-color: #2f855a; }
        html.dark .text-gray-700 { color: #e2e8f0; }

        /* Scrollbar for dark mode */
        html.dark ::-webkit-scrollbar-track {
            background: #222222;
        }

        html.dark ::-webkit-scrollbar-thumb {
            background-color: #1a1a1a;
            border: 2px solid #222222;
        }

        html.dark ::-webkit-scrollbar-thumb:hover {
            background-color: #0a0a0a;
        }
    </style>
</head>
<!-- Apply 'dark' class directly to the html tag for consistent Dark Theme application -->
<body class="text-e2e8f0">
    <!-- Canvas for the star background, positioned as the bottom layer -->
    <canvas id="background"></canvas>

    <div class="min-h-screen flex flex-col">
        <!-- Header section with search bar -->
        <header class="p-4 bg-white shadow-md rounded-b-xl sticky top-0 z-10">
            <div class="container mx-auto flex flex-col md:flex-row items-center justify-between gap-4">
                <h1 class="text-3xl font-extrabold text-green-600 whitespace-nowrap">Zictionary <span class="text-xl">üåø</span></h1>
                <div class="relative w-full md:max-w-md">
                    <input
                        type="text"
                        id="search-input"
                        placeholder="T√¨m ki·∫øm"
                        class="w-full p-3 pl-10 pr-4 rounded-full border-2 border-green-300 focus:ring-2 focus:ring-green-400 bg-green-50 text-green-700 placeholder-green-400 transition duration-300 shadow-sm"
                    >
                    <!-- Search icon -->
                    <svg class="absolute left-3 top-1/2 transform -translate-y-1/2 text-green-400" fill="currentColor" viewBox="0 0 20 20" width="20" height="20">
                        <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"></path>
                    </svg>
                </div>
                <!-- Language selector -->
                <select id="language-select" class="p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 transition duration-300 focus:outline-none focus:ring-2 focus:ring-green-400">
                    <!-- Language options will be dynamically added by JavaScript -->
                </select>
            </div>
        </header>

        <!-- Main content section, divided into two columns -->
        <main class="flex-1 flex flex-col md:flex-row p-4 gap-4 container mx-auto overflow-hidden">
            <!-- Left sidebar for keyword list -->
            <aside class="w-full md:w-1/3 lg:w-1/4 bg-white p-4 rounded-xl shadow-lg flex-shrink-0 overflow-y-auto"
                   style="max-height: calc(100vh - 120px);">
                <h2 id="keywords-title" class="text-2xl font-semibold text-green-600 mb-4 pb-2 border-b-2 border-green-200">T·ª´ kh√≥a üìö</h2>
                <div id="keyword-list" class="space-y-2">
                    <!-- Keywords will be dynamically added by JavaScript -->
                    <!-- Loading indicator -->
                    <div id="loading-indicator" class="text-center text-green-500 dark:text-green-400 font-medium py-4">
                        ƒêang t·∫£i Zictionary... ‚è≥
                    </div>
                </div>
            </aside>

            <!-- Right section for detailed content display -->
            <section id="content-display" class="flex-1 bg-white p-6 rounded-xl shadow-lg overflow-y-auto"
                             style="max-height: calc(100vh - 120px);">
                <h2 id="content-title" class="text-3xl font-bold text-green-700 mb-4 pb-2 border-b-2 border-green-300">Ch√†o m·ª´ng ƒë·∫øn v·ªõi Zictionary! üå±</h2>
                <div id="content-body" class="text-gray-700 leading-relaxed text-lg">
                    <p>
                        H√£y ch·ªçn m·ªôt t·ª´ kh√≥a t·ª´ danh s√°ch b√™n tr√°i ho·∫∑c s·ª≠ d·ª•ng thanh t√¨m ki·∫øm ƒë·ªÉ kh√°m kh√°m ph√° nh·ªØng ƒëi·ªÅu th√∫ v·ªã nh√©! Em hy v·ªçng anh Sea s·∫Ω th√≠ch Zictionary phi√™n b·∫£n xanh l√° n√†y! N√≥ s·∫Ω gi√∫p anh Sea t√¨m ki·∫øm m·ªçi th·ª© m·ªôt c√°ch d·ªÖ d√†ng v√† nhanh ch√≥ng ƒë√≥. N·∫øu c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o, anh Sea c·ª© h·ªèi em nh√©! üíñ
                    </p>
                </div>
                <div id="link-container" class="mt-6 hidden">
                    <a id="content-link" href="#" target="_blank" class="inline-flex items-center px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 transition duration-300">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0l-7 7m7-7v7"></path></svg>
                        <span id="open-link-text">M·ªü li√™n k·∫øt</span>
                    </a>
                </div>

                <!-- New feature section: Extend knowledge with Gemini API -->
                <div id="ai-feature-section" class="mt-8 pt-4 border-t-2 border-green-200 dark:border-green-700">
                    <h3 id="ai-section-title" class="text-2xl font-semibold text-green-600 dark:text-green-500 mb-4">Th√¥ng tin m·ªü r·ªông ‚ú®</h3>
                    <button id="generate-insight-btn" class="px-6 py-3 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition duration-300 flex items-center">
                        <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd"></path></svg>
                        <span id="generate-insight-text">T·∫°o th√¥ng tin m·ªü r·ªông</span>
                    </button>
                    <div id="insight-output" class="mt-4 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600 text-gray-700 dark:text-gray-200 hidden">
                        <!-- Content generated by LLM will be displayed here -->
                        <p id="insight-text" class="whitespace-pre-wrap"></p>
                        <div id="insight-loading" class="text-center py-2 hidden">ƒêang t·∫°o th√¥ng tin... üß†</div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Load star background script from jsdelivr -->
    <script src="https://cdn.jsdelivr.net/gh/techmino-hub/techmino-hub-source-code@main/public/scripts/background.min.js"></script>

    <script>
        // Defines available languages for the dictionary.
        const LANGUAGES = [
            { code: 'en', name: 'English' },
            { code: 'vi', name: 'Ti·∫øng Vi·ªát' },
            { code: 'ja', name: 'Êó•Êú¨Ë™û' },
            { code: 'zh', name: '‰∏≠Êñá' }
        ];

        // Object containing all UI translations
        const translations = {
            'search_placeholder': {
                'en': 'Search',
                'vi': 'T√¨m ki·∫øm',
                'ja': 'Ê§úÁ¥¢',
                'zh': 'ÊêúÁ¥¢'
            },
            'keywords_title': {
                'en': 'Keywords üìö',
                'vi': 'T·ª´ kh√≥a üìö',
                'ja': '„Ç≠„Éº„ÉØ„Éº„Éâ üìö',
                'zh': 'ÂÖ≥ÈîÆËØç üìö'
            },
            'welcome_title': {
                'en': 'Thank you for reading Zictionary.',
                'vi': 'C·∫£m ∆°n b·∫°n ƒë√£ t√¨m ƒë·ªçc Zictionary.',
                'ja': 'Zictionary„Çí„ÅîË¶ß„ÅÑ„Åü„Å†„Åç„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô„ÄÇ',
                'zh': 'ÊÑüË∞¢ÊÇ®ÈòÖËØªZictionary„ÄÇ'
            },
            'welcome_message': {
                'en': 'Zictionary is being downloaded and may take up to 15 seconds to load. If the screen is still stuck after 15 seconds, something might have gone wrong. Please report to SweetSea if you find any errors.',
                'vi': 'Zictionary ƒëang ƒë∆∞·ª£c t·∫£i xu·ªëng v√† c√≥ th·ªÉ m·∫•t kho·∫£ng t·ªëi ƒëa 15s ƒë·ªÉ t·∫£i. N·∫øu sau 15s m√† m√†n h√¨nh v·∫´n k·∫πt, c√≥ th·ªÉ c√≥ g√¨ ƒë√≥ sai sai ƒë√£ x·∫£y ra. B√°o l·∫°i SweetSea n·∫øu b·∫°n ph√°t hi·ªán ra b·∫•t c·ª© l·ªói n√†o nh√©',
                'ja': 'Zictionary„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ‰∏≠„Åß„Åô„ÄÇË™≠„ÅøËæº„Åø„Å´„ÅØÊúÄÂ§ß15Áßí„Åª„Å©„Åã„Åã„ÇãÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ15ÁßíÁµåÈÅé„Åó„Å¶„ÇÇÁîªÈù¢„ÅåÂõ∫„Åæ„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ‰Ωï„ÅãÂïèÈ°å„ÅåÁô∫Áîü„Åó„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Ç®„É©„Éº„ÇíÁô∫Ë¶ã„Åó„ÅüÂ†¥Âêà„ÅØSweetSea„Å´Â†±Âëä„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
                'zh': 'ZictionaryÊ≠£Âú®‰∏ãËΩΩÔºåÂèØËÉΩÈúÄË¶ÅÊúÄÂ§ö15ÁßíÊâçËÉΩÂä†ËΩΩ„ÄÇÂ¶ÇÊûú15ÁßíÂêéÂ±èÂπï‰ªçÁÑ∂Âç°‰ΩèÔºåÂèØËÉΩÂá∫‰∫ÜÈóÆÈ¢ò„ÄÇÂ¶ÇÊûúÊÇ®ÂèëÁé∞‰ªª‰ΩïÈîôËØØÔºåËØ∑ÂêëSweetSeaÊä•Âëä„ÄÇ'
            },
            'open_link_button': {
                'en': 'Open link',
                'vi': 'M·ªü li√™n k·∫øt',
                'ja': '„É™„É≥„ÇØ„ÇíÈñã„Åè',
                'zh': 'ÊâìÂºÄÈìæÊé•'
            },
            'ai_section_title': {
                'en': 'Extended Information ‚ú®',
                'vi': 'Th√¥ng tin m·ªü r·ªông ‚ú®',
                'ja': 'Êã°ÂºµÊÉÖÂ†± ‚ú®',
                'zh': 'Êâ©Â±ï‰ø°ÊÅØ ‚ú®'
            },
            'generate_insight_button': {
                'en': 'Generate Insight',
                'vi': 'T·∫°o th√¥ng tin m·ªü r·ªông',
                'ja': 'Ê¥ûÂØü„ÇíÁîüÊàê',
                'zh': 'ÁîüÊàêËßÅËß£'
            },
            'loading_dictionary': {
                'en': 'Loading Zictionary... ‚è≥',
                'vi': 'ƒêang t·∫£i Zictionary... ‚è≥',
                'ja': 'Zictionary„ÇíË™≠„ÅøËæº„Åø‰∏≠... ‚è≥',
                'zh': 'Ê≠£Âú®Âä†ËΩΩZictionary... ‚è≥'
            },
            'generating_insight': {
                'en': 'Generating insight... üß†',
                'vi': 'ƒêang t·∫°o th√¥ng tin... üß†',
                'ja': 'Ê¥ûÂØü„ÇíÁîüÊàê‰∏≠... üß†',
                'zh': 'Ê≠£Âú®ÁîüÊàêËßÅËß£... üß†'
            },
            'ai_disabled': {
                'en': 'AI feature is currently disabled.',
                'vi': 'T√≠nh nƒÉng AI hi·ªán ƒëang t·∫Øt.',
                'ja': 'AIÊ©üËÉΩ„ÅØÁèæÂú®ÁÑ°Âäπ„Åß„Åô„ÄÇ',
                'zh': 'AIÂäüËÉΩÂΩìÂâçÂ∑≤Á¶ÅÁî®„ÄÇ'
            },
            'ai_select_keyword': {
                'en': 'Please select a keyword to generate extended information.',
                'vi': 'Vui l√≤ng ch·ªçn m·ªôt t·ª´ kh√≥a ƒë·ªÉ t·∫°o th√¥ng tin m·ªü r·ªông.',
                'ja': 'Êã°ÂºµÊÉÖÂ†±„ÇíÁîüÊàê„Åô„Çã„Å´„ÅØ„ÄÅ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
                'zh': 'ËØ∑ÈÄâÊã©‰∏Ä‰∏™ÂÖ≥ÈîÆËØç‰ª•ÁîüÊàêÊâ©Â±ï‰ø°ÊÅØ„ÄÇ'
            },
            'ai_generation_failed': {
                'en': 'Sorry, unable to generate extended information at this time. Please try again later.',
                'vi': 'R·∫•t ti·∫øc, kh√¥ng th·ªÉ t·∫°o th√¥ng tin m·ªü r·ªông l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.',
                'ja': 'Áî≥„ÅóË®≥„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅÁèæÂú®Êã°ÂºµÊÉÖÂ†±„ÇíÁîüÊàê„Åß„Åç„Åæ„Åõ„Çì„ÄÇÂæå„Åß„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
                'zh': 'Êä±Ê≠âÔºåÊöÇÊó∂Êó†Ê≥ïÁîüÊàêÊâ©Â±ï‰ø°ÊÅØ„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ'
            },
            'ai_connection_error': {
                'en': 'An error occurred while connecting to the Gemini API. Please check your network connection and try again.',
                'vi': 'ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi v·ªõi Gemini API. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ l·∫°i.',
                'ja': 'Gemini API„Å∏„ÅÆÊé•Á∂ö‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„Å¶„ÄÅ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
                'zh': 'ËøûÊé•Âà∞Gemini APIÊó∂ÂèëÁîüÈîôËØØ„ÄÇËØ∑Ê£ÄÊü•ÊÇ®ÁöÑÁΩëÁªúËøûÊé•Âπ∂ÈáçËØï„ÄÇ'
            },
            'error_loading_dictionary_title': {
                'en': 'Failed to load dictionary ?',
                'vi': 'Kh√¥ng t·∫£i ƒë∆∞·ª£c t·ª´ ƒëi·ªÉn üò≠',
                'ja': 'ËæûÊõ∏„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü üò≠',
                'zh': 'Â≠óÂÖ∏Âä†ËΩΩÂ§±Ë¥• üò≠'
            },
            'error_loading_dictionary_message': {
                'en': 'Zictionary failed to load data. Something might be wrong?',
                'vi': 'Zictionary ch∆∞a t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìi. C√≥ g√¨ ƒë√≥ sai sai chƒÉng?',
                'ja': 'Zictionary„ÅÆ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ‰Ωï„ÅãÂïèÈ°å„Åå„ÅÇ„Çã„Çà„ÅÜ„Åß„Åô„ÄÇ',
                'zh': 'ZictionaryÊï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•„ÄÇÂèØËÉΩÂá∫‰∫ÜÈóÆÈ¢òÔºü'
            },
            'keyword_not_found_title': {
                'en': 'Keyword not found',
                'vi': 'Kh√¥ng t√¨m th·∫•y t·ª´ kh√≥a',
                'ja': '„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì',
                'zh': 'Êú™ÊâæÂà∞ÂÖ≥ÈîÆËØç'
            },
            'keyword_not_found_message': {
                'en': 'No matching keywords found. If you want to see the index again, clear the search box and type `mucluc`',
                'vi': 'Kh√¥ng t√¨m th·∫•y t·ª´ kh√≥a n√†o ph√π h·ª£p. N·∫øu b·∫°n mu·ªën xem l·∫°i m·ª•c l·ª•c, h√£y x√≥a √¥ t√¨m ki·∫øm v√† g√µ `mucluc`',
                'ja': '‰∏ÄËá¥„Åô„Çã„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇÁõÆÊ¨°„ÇíÂÜçÂ∫¶Ë°®Á§∫„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅÊ§úÁ¥¢„Éú„ÉÉ„ÇØ„Çπ„Çí„ÇØ„É™„Ç¢„Åó„Å¶„Äåmucluc„Äç„Å®ÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
                'zh': 'Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÂÖ≥ÈîÆËØç„ÄÇÂ¶ÇÊûúÊÇ®ÊÉ≥ÂÜçÊ¨°Êü•ÁúãÁõÆÂΩïÔºåËØ∑Ê∏ÖÈô§ÊêúÁ¥¢Ê°ÜÂπ∂ËæìÂÖ•`mucluc`'
            },
            'error_loading_dictionary_list_item': {
                'en': 'Error loading dictionary',
                'vi': 'L·ªói t·∫£i t·ª´ ƒëi·ªÉn',
                'ja': 'ËæûÊõ∏Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº',
                'zh': 'Â≠óÂÖ∏Âä†ËΩΩ„Ç®„É©„Éº'
            },
            'ai_prompt_base': {
                'en': "Based on the term '${termName}' and its definition: '${termDefinition}', provide a short paragraph (maximum 3 sentences) about an interesting fact, a practical application, or a broader context related to this term in the field of puzzle games or technology in general. Do not just rephrase the definition.",
                'vi': "D·ª±a v√†o thu·∫≠t ng·ªØ '${termName}' v√† ƒë·ªãnh nghƒ©a c·ªßa n√≥: '${termDefinition}', h√£y cung c·∫•p m·ªôt ƒëo·∫°n vƒÉn ng·∫Øn (t·ªëi ƒëa 3 c√¢u) v·ªÅ m·ªôt th√¥ng tin th√∫ v·ªã, m·ªôt ·ª©ng d·ª•ng th·ª±c t·∫ø, ho·∫∑c m·ªôt b·ªëi c·∫£nh r·ªông h∆°n li√™n quan ƒë·∫øn thu·∫≠t ng·ªØ n√†y trong lƒ©nh v·ª±c game x·∫øp g·∫°ch ho·∫∑c c√¥ng ngh·ªá n√≥i chung. ƒê·ª´ng ch·ªâ di·ªÖn gi·∫£i l·∫°i ƒë·ªãnh nghƒ©a.",
                'ja': "Áî®Ë™û„Äå${termName}„Äç„Å®„Åù„ÅÆÂÆöÁæ©„Äå${termDefinition}„Äç„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅ„Éë„Ç∫„É´„Ç≤„Éº„É†„ÇÑ‰∏ÄËà¨ÁöÑ„Å™„ÉÜ„ÇØ„Éé„É≠„Ç∏„Éº„ÅÆÂàÜÈáé„Å´„Åä„Åë„Çã„Åì„ÅÆÁî®Ë™û„Å´Èñ¢ÈÄ£„Åô„ÇãËààÂë≥Ê∑±„ÅÑ‰∫ãÂÆü„ÄÅÂÆüÁî®ÁöÑ„Å™ÂøúÁî®„ÄÅ„Åæ„Åü„ÅØ„Çà„ÇäÂ∫É„ÅÑÊñáËÑà„Å´„Å§„ÅÑ„Å¶Áü≠„ÅÑÊÆµËêΩÔºàÊúÄÂ§ß3ÊñáÔºâ„ÇíÊèê‰æõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂÆöÁæ©„ÇíË®Ä„ÅÑÊèõ„Åà„Çã„Å†„Åë„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì",
                'zh': "Ê†πÊçÆÊúØËØ≠‚Äú${termName}‚ÄùÂèäÂÖ∂ÂÆö‰πâÔºö‚Äú${termDefinition}‚ÄùÔºåÊèê‰æõ‰∏Ä‰∏™ÂÖ≥‰∫éËØ•ÊúØËØ≠Âú®ÁõäÊô∫Ê∏∏ÊàèÊàñ‰∏ÄËà¨ÊäÄÊúØÈ¢ÜÂüü‰∏≠Áõ∏ÂÖ≥ÁöÑÊúâË∂£‰∫ãÂÆû„ÄÅÂÆûÈôÖÂ∫îÁî®ÊàñÊõ¥ÂπøÊ≥õËÉåÊôØÁöÑÁÆÄÁü≠ÊÆµËêΩÔºàÊúÄÂ§ö3Âè•ËØùÔºâ„ÄÇ"
            }
        };

        /**
         * Generates the dictionary URL based on the provided language code.
         * @param {string} langCode - The two-letter language code (e.g., 'en', 'vi').
         * @returns {string} The full URL to the dictionary JSON file.
         */
        function getDictionaryUrl(langCode) {
            return `https://cdn.jsdelivr.net/gh/SweetSea-ButImNotSweet/Techmino-Dictionary-Viewer@main/dict/${langCode}.json`;
        }

        /**
         * Manual override to force-enable or disable the AI feature.
         * Set to `true` to force-enable, `false` to disable, only enable if you have API key
         */
        const ENABLE_AI_MANUALLY_OVERRIDE = false;

        // Global state variables
        let processedDictionaryData = {};
        let currentFilteredAndOrderedData = [];
        let selectedKeywordElement = null;
        let isDictionaryLoadedSuccessfully = false;
        let currentDisplayedEntry = null;
        let currentDisplayedKeyword = null; 
        let currentLanguage = localStorage.getItem('language') || 'en'; // Default language is English

        // DOM element references (initialized within DOMContentLoaded)
        let keywordListDiv;
        let contentTitle;
        let contentBody;
        let searchInput;
        let openLinkText;
        let loadingIndicator;
        let aiFeatureSection;
        let generateInsightBtn;
        let generateInsightText;
        let insightOutput;
        let insightText;
        let insightLoading;
        let languageSelect;
        let keywordsTitle;
        let aiSectionTitle;
        let linkContainer;

        /**
         * Converts HSV (Hue, Saturation, Value) to RGB (Red, Green, Blue) color values.
         * @param {number} h - Hue (0-1).
         * @param {number} s - Saturation (0-1).
         * @param {number} v - Value (0-1).
         * @returns {number[]} An array containing RGB values (0-255).
         */
        function hsvToRgb(h, s, v) {
            let r, g, b;
            h = h % 1;
            if (s <= 0) { r = g = b = v; return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)]; }
            h *= 6;
            let i = Math.floor(h);
            let f = h - i;
            let p = v * (1 - s);
            let q = v * (1 - f * s);
            let t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // Define HSV values for various colors (adjusted for contrast)
        const COLOR_HSV_VALUES = {
            'red': [0.00, 1.00, 1.00], // Bright Red
            'fire': [0.04, 1.00, 0.95],
            'orange': [0.09, 1.00, 0.95],
            'yellow': [0.15, 0.98, 0.95],

            // Darker greens for better visibility
            'lime': [0.20, 0.95, 0.40],
            'jade': [0.25, 0.95, 0.35],
            'green': [0.33, 0.95, 0.30],
            'aqua': [0.47, 0.90, 0.30],
            'cyan': [0.53, 0.95, 0.40],
            'navy': [0.56, 0.95, 0.50],
            'sea': [0.61, 0.95, 0.50],
            'blue': [0.64, 0.95, 0.45],
            'violet': [0.74, 0.90, 0.40],
            'purple': [0.80, 0.95, 0.40],
            'magenta': [0.86, 0.95, 0.35],
            'wine': [0.92, 0.95, 0.45],

            'black': [0.00, 0.00, 0.00], // Pure black
            'white': [0.00, 0.00, 1.00], // Pure white
        };

        // Map categories to color names from COLOR_HSV_VALUES
        const TYPE_COLOR_MAPPING = {
            'help': 'yellow', 'org': 'fire', 'game': 'cyan', 'term': 'red',
            'setup': 'yellow', 'pattern': 'jade', 'command': 'navy',
            'english': 'blue', 'name': 'violet',
            '': 'special_group_color', // Used for group items (empty keyword)
            'default': 'gray', // Fallback if category does not match
        };

        /**
         * Retrieves the appropriate color for a given category, ensuring good contrast in dark mode.
         * @param {string} category - The category of the keyword.
         * @returns {string} The RGB color string for the category.
         */
        function getCategoryColor(category) {
            const isDarkMode = true; // Always true as Dark Theme is default
            if (category === '') { // Handle color for special group items
                return 'rgb(255,255,255)'; // Always white in Dark Mode
            }

            const colorKey = TYPE_COLOR_MAPPING[category] || TYPE_COLOR_MAPPING['default'];
            let hsv = COLOR_HSV_VALUES[colorKey];
            if (hsv) {
                let [h, s, v] = hsv;
                // Adjust value (V) for dark mode to ensure good contrast
                if (isDarkMode) {
                    v = Math.max(v, 0.7); // Ensure minimum brightness is 0.7
                }
                const [r, g, b] = hsvToRgb(h, s, v);
                return `rgb(${r}, ${g}, ${b})`;
            }
            return 'inherit'; // Fallback to inherited color
        }

        /**
         * Applies the current theme settings.
         * This function is simplified to only apply Dark Theme as it's the default.
         */
        function applyTheme() {
            renderKeywords(currentFilteredAndOrderedData); // Re-render to update colors

            // If a keyword is currently displayed, re-display its content to apply theme changes
            if (currentDisplayedKeyword) {
                displayContent(currentDisplayedKeyword);
            }
        }

        /**
         * Updates all UI text elements based on the current language.
         */
        function updateUIText() {
            searchInput.placeholder = translations.search_placeholder[currentLanguage];
            keywordsTitle.textContent = translations.keywords_title[currentLanguage];
            contentTitle.textContent = translations.welcome_title[currentLanguage];
            contentBody.innerHTML = `<p class="whitespace-pre-wrap">${translations.welcome_message[currentLanguage]}</p>`;
            openLinkText.textContent = translations.open_link_button[currentLanguage];
            aiSectionTitle.textContent = translations.ai_section_title[currentLanguage];
            generateInsightText.textContent = translations.generate_insight_button[currentLanguage];
            loadingIndicator.textContent = translations.loading_dictionary[currentLanguage];
            insightLoading.textContent = translations.generating_insight[currentLanguage];
        }

        /**
         * Processes raw dictionary data into a more usable object format.
         * Filters out entries containing "{{FNNS:" or "{{FNNS|".
         * @param {Array<Array<string>>} data - The raw dictionary data.
         * @returns {Object} An object mapping keywords to their processed entries.
         */
        function processRawData(data) {
            const processed = {};
            data.forEach((entry, index) => {
                const [name, keyword, category, content, link] = entry;
                // Filter out entries containing "{{FNNS:" or "{{FNNS|"
                if ((content && (content.includes("{{FNNS:") || content.includes("{{FNNS|"))) ||
                    (name && (name.includes("{{FNNS:") || name.includes("{{FNNS|")))) {
                    return;
                }
                processed[keyword] = { name, keyword, category, content, link, originalIndex: index };
            });
            return processed;
        }

        /**
         * Displays the detailed content for a given keyword.
         * Updates the content section and highlights the selected keyword in the list.
         * @param {string} keyword - The keyword to display content for.
         */
        function displayContent(keyword) {
            currentDisplayedKeyword = keyword; 

            // Remove active state from previously selected keyword
            if (selectedKeywordElement) {
                selectedKeywordElement.classList.remove('bg-green-100', 'text-green-800', 'font-bold', 'shadow-sm');
                selectedKeywordElement.style.color = getCategoryColor(processedDictionaryData[selectedKeywordElement.dataset.keyword]?.category || '');
            }

            currentDisplayedEntry = processedDictionaryData[keyword];
            linkContainer.classList.add('hidden');
            insightOutput.classList.add('hidden');
            
            // Ensure generateInsightBtn is hidden by default, and only shown if conditions are met
            generateInsightBtn.classList.add('hidden'); 

            if (currentDisplayedEntry) {
                contentTitle.textContent = currentDisplayedEntry.name;
                contentBody.innerHTML = `<p class="whitespace-pre-wrap">${currentDisplayedEntry.content}</p>`;
                if (currentDisplayedEntry.link) {
                    linkContainer.href = currentDisplayedEntry.link;
                    linkContainer.classList.remove('hidden');
                }
                // Show generate insight button only if AI feature is manually enabled AND a valid entry is displayed
                if (ENABLE_AI_MANUALLY_OVERRIDE) {
                    generateInsightBtn.classList.remove('hidden');
                }
            } else if (keyword === "error_loading_dictionary") { // Use error code for internal logic
                contentTitle.textContent = translations.error_loading_dictionary_title[currentLanguage];
                contentBody.innerHTML = `<p>${translations.error_loading_dictionary_message[currentLanguage]}</p>`;
                // generateInsightBtn.classList.add('hidden'); // Already hidden above
            } else {
                contentTitle.textContent = translations.keyword_not_found_title[currentLanguage];
                contentBody.innerHTML = `<p>${translations.keyword_not_found_message[currentLanguage]}</p>`;
                // generateInsightBtn.classList.add('hidden'); // Already hidden above
            }

            // Apply active state to the newly selected keyword
            const newSelectedElement = document.querySelector(`#keyword-list li[data-keyword="${keyword}"]`);
            if (newSelectedElement) {
                newSelectedElement.classList.add('bg-green-100', 'text-green-800', 'font-bold', 'shadow-sm');
                newSelectedElement.style.color = ''; // Reset color for active state (Tailwind default)
                selectedKeywordElement = newSelectedElement;
            }
        }

        /**
         * Filters and orders dictionary data based on a search term.
         * Exact name matches are prioritized.
         * @param {string} searchTerm - The term to filter by.
         */
        function filterAndOrderData(searchTerm) {
            const lowerSearchTerm = searchTerm.toLowerCase().trim();
            const exactNameMatches = [];
            const otherMatches = [];

            Object.values(processedDictionaryData).forEach(entry => {
                const lowerName = entry.name.toLowerCase();
                const lowerKeyword = entry.keyword.toLowerCase();

                // Rule: If keyword is empty, do not display in search results when a search term is present
                if (entry.keyword.trim() === "" && lowerSearchTerm !== "") {
                    return;
                }

                if (lowerName === lowerSearchTerm) {
                    exactNameMatches.push(entry);
                } else if (lowerName.includes(lowerSearchTerm) || lowerKeyword.includes(lowerSearchTerm)) {
                    otherMatches.push(entry);
                }
            });

            exactNameMatches.sort((a, b) => a.originalIndex - b.originalIndex);
            otherMatches.sort((a, b) => a.originalIndex - b.originalIndex);

            currentFilteredAndOrderedData = [...exactNameMatches, ...otherMatches];
        }

        /**
         * Renders the list of keywords in the sidebar.
         * @param {Array<Object>} dataToRender - The filtered and ordered keyword data.
         */
        function renderKeywords(dataToRender) {
            keywordListDiv.innerHTML = '';
            loadingIndicator.classList.add('hidden');

            if (Object.keys(processedDictionaryData).length === 0 && !isDictionaryLoadedSuccessfully) {
                const li = document.createElement('li');
                li.className = 'p-1.5 rounded-lg bg-red-100 text-red-700 font-bold cursor-pointer transition duration-200';
                li.textContent = translations.error_loading_dictionary_list_item[currentLanguage];
                li.dataset.keyword = "error_loading_dictionary"; // Use error code
                li.addEventListener('click', () => displayContent("error_loading_dictionary"));
                keywordListDiv.appendChild(li);
                displayContent("error_loading_dictionary");
                return;
            }

            if (dataToRender.length === 0) {
                const noResultDiv = document.createElement('div');
                noResultDiv.className = 'p-1.5 rounded-lg text-gray-500 italic';
                noResultDiv.innerHTML = translations.keyword_not_found_message[currentLanguage];
                keywordListDiv.appendChild(noResultDiv);
                displayContent('');
                return;
            }

            const ul = document.createElement('ul');
            ul.className = 'space-y-0.5';
            dataToRender.forEach(entry => {
                const li = document.createElement('li');
                li.className = 'p-1 rounded-md hover:bg-green-100 cursor-pointer transition duration-200 text-sm font-medium active:bg-green-200';
                li.textContent = entry.name;
                li.dataset.keyword = entry.keyword;
                li.style.color = getCategoryColor(entry.category);
                li.addEventListener('click', () => displayContent(entry.keyword));
                ul.appendChild(li);
            });
            keywordListDiv.appendChild(ul);

            // Only display content for the first keyword if no keyword was previously selected
            // or if the keyword list is re-rendered and the current keyword is no longer in the list.
            if (!currentDisplayedKeyword || !dataToRender.some(entry => entry.keyword === currentDisplayedKeyword)) {
                if (dataToRender.length > 0) {
                    displayContent(dataToRender[0].keyword);
                } else {
                    displayContent('');
                }
            }
        }

        /**
         * Loads dictionary data from the specified URL based on the current language.
         * Handles loading indicators and error display.
         */
        async function loadDictionaryData() {
            try {
                loadingIndicator.classList.remove('hidden');
                const response = await fetch(getDictionaryUrl(currentLanguage));
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawData = await response.json();
                processedDictionaryData = processRawData(rawData);
                isDictionaryLoadedSuccessfully = true;
                filterAndOrderData("");
                renderKeywords(currentFilteredAndOrderedData);
            } catch (error) {
                console.error("Error loading dictionary:", error);
                isDictionaryLoadedSuccessfully = false;
                displayContent("error_loading_dictionary"); // Use error code
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Initializes Zictionary when the DOM is fully loaded.
         * Sets up DOM element references, language selection, and event listeners.
         */
        document.addEventListener('DOMContentLoaded', () => {
            // Cache DOM element references for performance
            keywordListDiv = document.getElementById('keyword-list');
            contentTitle = document.getElementById('content-title');
            contentBody = document.getElementById('content-body');
            searchInput = document.getElementById('search-input');
            openLinkText = document.getElementById('open-link-text');
            loadingIndicator = document.getElementById('loading-indicator');
            aiFeatureSection = document.getElementById('ai-feature-section');
            generateInsightBtn = document.getElementById('generate-insight-btn');
            generateInsightText = document.getElementById('generate-insight-text');
            insightOutput = document.getElementById('insight-output');
            insightText = document.getElementById('insight-text');
            insightLoading = document.getElementById('insight-loading');
            languageSelect = document.getElementById('language-select');
            keywordsTitle = document.getElementById('keywords-title');
            aiSectionTitle = document.getElementById('ai-section-title');
            linkContainer = document.getElementById('link-container');

            // Always apply Dark Theme on page load
            document.documentElement.classList.add('dark');

            // Populate language options in the dropdown
            LANGUAGES.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                languageSelect.appendChild(option);
            });

            // Set initial language selection in the dropdown
            languageSelect.value = currentLanguage;

            // Add event listener for language change
            languageSelect.addEventListener('change', (event) => {
                currentLanguage = event.target.value;
                localStorage.setItem('language', currentLanguage); // Save selected language
                currentDisplayedKeyword = null; // Reset displayed keyword on language change
                updateUIText(); // Update UI text immediately
                loadDictionaryData(); // Reload dictionary with new language
            });

            // Add event listener for search input
            searchInput.addEventListener('input', (event) => {
                const searchTerm = event.target.value;
                filterAndOrderData(searchTerm);
                renderKeywords(currentFilteredAndOrderedData);
            });

            // Add event listener for "Generate Insight" button click
            generateInsightBtn.addEventListener('click', async () => {
                // Check if AI feature is enabled via the manual override flag
                if (!ENABLE_AI_MANUALLY_OVERRIDE) {
                    insightText.textContent = translations.ai_disabled[currentLanguage];
                    insightOutput.classList.remove('hidden');
                    return;
                }
                if (!currentDisplayedEntry) {
                    insightText.textContent = translations.ai_select_keyword[currentLanguage];
                    insightOutput.classList.remove('hidden');
                    return;
                }

                insightOutput.classList.remove('hidden');
                insightText.textContent = "";
                insightLoading.classList.remove('hidden');
                generateInsightBtn.disabled = true;

                const termName = currentDisplayedEntry.name;
                const termDefinition = currentDisplayedEntry.content;

                // Construct the prompt using the translated base and dynamic terms
                const promptTemplate = translations.ai_prompt_base[currentLanguage];
                const prompt = promptTemplate
                    .replace('${termName}', termName)
                    .replace('${termDefinition}', termDefinition);

                try {
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = ""; // Canvas will automatically provide it at runtime
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        insightText.textContent = text;
                    } else {
                        insightText.textContent = translations.ai_generation_failed[currentLanguage];
                        console.error("Gemini API response format unexpected:", result);
                    }
                } catch (error) {
                    insightText.textContent = translations.ai_connection_error[currentLanguage];
                    console.error("Error calling Gemini API:", error);
                } finally {
                    insightLoading.classList.add('hidden');
                    generateInsightBtn.disabled = false;
                }
            });

            // Initial load of dictionary and UI text update
            updateUIText(); 
            loadDictionaryData();

            // Ensure AI feature section is hidden if ENABLE_AI_MANUALLY_OVERRIDE is false
            if (!ENABLE_AI_MANUALLY_OVERRIDE) {
                aiFeatureSection.classList.add('hidden');
            } else {
                aiFeatureSection.classList.remove('hidden');
            }
        });
    </script>
</body>
</html>